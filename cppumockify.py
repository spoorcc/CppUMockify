#!/usr/bin/env python3

# Copyright (c) 2015, Marco Molteni.
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""
Simple script to generate a skeleton mock file and function for CppUMock.
It expects to be run in the directory containing the mocks.
"""


import os.path
import argparse
import logging

from pycparser import c_parser, c_ast

FORMAT = '%(asctime)-15s %(levelname)s %(message)s'
logging.basicConfig(format=FORMAT)
logger = logging.getLogger(__name__)
logger.setLevel(10)

FILE_HEADER = '''
// autogenerated by cppumockify.py
#include "CppUTestExt/MockSupport.h"

extern "C" {
#include "@include@"
}

'''

VOID_MOCK = '''
{return_type} {function}({args}) {{
    mock().actualCall("{function}"){with_parameters};
}}'''.lstrip("\n")

NON_VOID_MOCK = '''
{return_type} {function}({args}) {{
    mock().actualCall("{function}"){with_parameters};
    if mock().hasReturnValue() {{
        return mock().{return_value};
    }}
    return WRITEME;
}}'''.lstrip("\n")

RETURN_VALUES = {
    # All the return values supported by CppUMock.
    'int':               'intReturnValue()',
    'unsigned int':      'unsignedIntReturnValue()',
    'long int':          'longIntReturnValue()',
    'unsigned long int': 'unsignedLongIntReturnValue()',
    'const char*':       'stringReturnValue()',
    'double':            'doubleReturnValue()',
    'void*':             'pointerReturnValue()',
    'const void*':       'constPointerReturnValue()',

    # Synthetic case
    'char*':             'pointerReturnValue()',
}

class MockError(Exception):
    ''' Error class for CppUMockify '''
    def __init__(self, value):
        super().__init__()
        self.value = value

    def __str__(self):
        return repr(self.value)


def generate_mock(mocked_module, mock_prototype):
    ''' Generates the mock '''
    mock_filename = "{0}_mock.cpp".format(mocked_module)
    include_filename = "{0}.h".format(mocked_module)
    logger.debug("working directory: %s", os.getcwd())
    logger.debug("mock_filename: %s", mock_filename)
    logger.debug("include_filename: %s", include_filename)
    logger.debug("mock_prototype: %s", mock_prototype)
    if os.path.exists(mock_filename):
        logger.debug("Mock file exists")
        mock_file = open(mock_filename, "a")
    else:
        logger.debug("Creating mock file")
        mock_file = open(mock_filename, "w")
        write_header(mock_file, FILE_HEADER, include_filename)
    add_mock_function(mock_file, mock_prototype)
    mock_file.close()


def write_header(file, header, include):
    ''' Writes the file header '''
    logger.debug("Adding file header")
    header = header.replace("@include@", include)
    file.write(header)


def add_mock_function(file, prototype):
    ''' Add the mock function to the mock file '''
    logger.debug("Adding mock function")
    # TODO: parse file to see if mock function is already there...
    try:
        mock_function = generate_mock_boilerplate(prototype)
        file.write("\n" + mock_function + "\n")
    except MockError as exc:
        logger.error("Error: %s", exc.value)


def generate_mock_boilerplate(prototype):
    ''' Generate the boilerplate for the mock '''

    func_decl, function_name = parse_function_from_prototype(prototype)

    type_name = generate_type_name(func_decl)

    args, with_parameters = generate_args(prototype, func_decl.args)

    if type_name == 'void':
        mock = VOID_MOCK.format(
            return_type=type_name,
            function=function_name,
            args=args,
            with_parameters=with_parameters)
    elif type_name in RETURN_VALUES:
        mock = NON_VOID_MOCK.format(
            return_type=type_name,
            function=function_name,
            args=args,
            with_parameters=with_parameters,
            return_value=RETURN_VALUES[type_name])
    else:
        raise MockError("Internal error, cannot handle: {0} [{1}]".format(
            prototype, type_name))

    return mock

    # Output parameters:
    #
    # void foo(int* bar)
    # {
    #     mock().actualCall("foo").
    #         withOutputParameter("bar", bar);
    # }

def parse_function_from_prototype(prototype):
    ''' Parse the function from the prototype '''
    # Thanks to cdecl.py from pycparser
    parser = c_parser.CParser()
    try:
        ast = parser.parse(prototype)
    except c_parser.ParseError as exc:
        raise MockError("Parse error: '{0}' with input: '{1}'".format(
            str(exc), prototype))
    decl = ast.ext[-1]
    if not isinstance(decl, c_ast.Decl):
        raise MockError("Not a valid declaration: " + prototype)
    # decl.show(); print("")

    if not isinstance(decl.type, c_ast.FuncDecl):
        raise MockError("Not a function declaration: " + prototype)

    # storage is, for example, "static" in "static void f();"
    if decl.storage:
        storage = ' '.join(decl.storage)
        raise MockError("Cannot mock a function with storage: " + storage)

    return (decl.type, decl.name)


def generate_type_name(func_decl):
    ''' Generates the type name '''

    pointer = False
    if isinstance(func_decl.type, c_ast.PtrDecl):
        # void* f(); =>
        # Decl: f, [], [], []
        #   FuncDecl:
        #     PtrDecl: []                   <== here
        #       TypeDecl: f, []
        #         IdentifierType: ['void']
        type_decl = func_decl.type.type
        pointer = True
    elif isinstance(func_decl.type, c_ast.TypeDecl):
        # void f(); =>
        # Decl: f, [], [], []
        #   FuncDecl:
        #     TypeDecl: f, []               <== here
        #       IdentifierType: ['void']
        type_decl = func_decl.type
    else:
        raise MockError("Internal error parsing: " + func_decl.name)

    identifier_type = type_decl.type

    # e.g.: "int" in "int f()"
    type_name = ' '.join(identifier_type.names)
    if pointer:
        type_name += '*'
    # e.g.: "const" in "const char* f()"
    try:
        type_name = type_decl.quals[0] + " " + type_name
    except IndexError:
        pass

    return type_name

def generate_args(prototype, param_list):
    ''' Generate the arguments '''
    if not param_list:
        return '', ''
    args = ''
    with_parameters = ''
    comma = ''
    for decl in param_list.params:
        # Decl: k, [], [], []
        #     TypeDecl: k, []
        #         IdentifierType: ['int']
        # Decl: i, [], [], []
        #     PtrDecl: []
        #         TypeDecl: i, []
        #             IdentifierType: ['char']
        #decl.show()
        param_name = decl.name
        if isinstance(decl.type, c_ast.TypeDecl):
            type_decl = decl.type
            identifier_type = type_decl.type
            param_type = identifier_type.names[0]
        elif isinstance(decl.type, c_ast.PtrDecl):
            type_decl = decl.type.type
            identifier_type = type_decl.type
            param_type = identifier_type.names[0] + '*'
        else:
            raise MockError("Internal error parsing arguments in: '{0}'"
                            .format(prototype))

        if not param_name:
            # Unnamed void argument: "f(void);" ?
            if param_type == 'void':
                # FIXME Not 100% robust if other arguments are present
                return '', ''
            else:
                raise MockError("Cannot mock unnamed arguments. "
                                "Please rewrite the prototype: '{0}'"
                                .format(prototype))
        try:
            param_type = type_decl.quals[0] + " " + param_type
        except IndexError:
            pass

        args += '{comma}{param_type} {param_name}'.format(
            comma=comma,
            param_type=param_type,
            param_name=param_name)
        with_parameters += \
            '\n        .withParameter("{0}", {0})'.format(param_name)
        comma = ', '

    return args, with_parameters


def main():
    ''' Main entry for cli usage '''
    parser = argparse.ArgumentParser(
        description='Generate CppUMock boilerplate code.')
    parser.add_argument('module', metavar='<module>', type=str,
                        help='Module that will be mocked')
    parser.add_argument('prototype', metavar='<prototype>', type=str,
                        help='Function prototype to generate the mock for')

    args = parser.parse_args()

    generate_mock(args.module, args.prototype)


if __name__ == "__main__":
    main()
