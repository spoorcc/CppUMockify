#!/usr/bin/env python3

# Copyright (c) 2015, Marco Molteni.
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""
Simple script to generate a skeleton mock file and function for CppUMock.
It expects to be run in the directory containing the mocks.
"""


import os.path
import argparse
import logging

from .prototype import Prototype
from .mock_function import MockFunction
from .common import MockError

FORMAT = '%(asctime)-15s %(levelname)s %(message)s'
logging.basicConfig(format=FORMAT)
logger = logging.getLogger(__name__)
logger.setLevel(10)


FILE_HEADER = '''
// autogenerated by cppumockify.py
#include "CppUTestExt/MockSupport.h"

extern "C" {
#include "@include@"
}

'''


def generate_mock(mocked_module, mock_prototype):
    ''' Generates the mock '''
    mock_filename = "{0}_mock.cpp".format(mocked_module)
    include_filename = "{0}.h".format(mocked_module)
    logger.debug("working directory: %s", os.getcwd())
    logger.debug("mock_filename: %s", mock_filename)
    logger.debug("include_filename: %s", include_filename)
    logger.debug("mock_prototype: %s", mock_prototype)
    if os.path.exists(mock_filename):
        logger.debug("Mock file exists")
        mock_file = open(mock_filename, "a")
    else:
        logger.debug("Creating mock file")
        mock_file = open(mock_filename, "w")
        write_header(mock_file, FILE_HEADER, include_filename)
    add_mock_function(mock_file, mock_prototype)
    mock_file.close()


def write_header(file, header, include):
    ''' Writes the file header '''
    logger.debug("Adding file header")
    header = header.replace("@include@", include)
    file.write(header)


def add_mock_function(file, prototype):
    ''' Add the mock function to the mock file '''
    logger.debug("Adding mock function")
    # TODO: parse file to see if mock function is already there...
    try:
        mock_function = generate_mock_boilerplate(prototype)
        file.write("\n" + mock_function + "\n")
    except MockError as exc:
        logger.error("Error: %s", exc.value)


def generate_mock_boilerplate(prototype):
    ''' Create mock function from prototype '''

    func_to_mock = Prototype(prototype)
    return MockFunction(func_to_mock).generate()


def main():
    ''' Main entry for cli usage '''
    parser = argparse.ArgumentParser(
        description='Generate CppUMock boilerplate code.')
    parser.add_argument('module', metavar='<module>', type=str,
                        help='Module that will be mocked')
    parser.add_argument('prototype', metavar='<prototype>', type=str,
                        help='Function prototype to generate the mock for')

    args = parser.parse_args()

    generate_mock(args.module, args.prototype)


if __name__ == "__main__":
    main()
